<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spotify Fair Artist Shuffle v0.44</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#121923; --muted:#9fb0c3; --accent:#1db954; --danger:#ff5c5c; --text:#e8f0f6;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0f14,#0b0f14 60%,#0e1420);color:var(--text);font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"}
    header{padding:24px 16px;max-width:960px;margin:0 auto}
    h1{margin:0 0 8px;font-size:28px}
    .sub{color:var(--muted);font-size:14px}
    main{max-width:960px;margin:0 auto;padding:0 16px 80px}
    .card{background:var(--card);border:1px solid #1c2734;border-radius:16px;padding:16px 16px 12px;box-shadow:0 8px 24px rgba(0,0,0,.25);margin:16px 0}
    label{display:block;margin:8px 0 4px;color:#c8d6e5}
    select, input[type=text]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #263445;background:#0c121a;color:var(--text)}
    button{appearance:none;border:0;border-radius:999px;padding:10px 16px;background:var(--accent);color:#082412;font-weight:700;cursor:pointer}
    button[disabled]{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .row>*{flex:1 1 260px}
    .muted{color:var(--muted)}
    .danger{background:var(--danger);color:#2b0d0d}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#0c121a;border:1px solid #263445}
    .hidden{display:none}
    progress{width:100%;height:14px}
    .logs{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;white-space:pre-wrap;background:#0c121a;border:1px solid #263445;border-radius:12px;padding:12px;color:#cfe3ff}
    a.link{color:#7ed7ff}
    footer{max-width:960px;margin:32px auto;padding:0 16px 24px;color:var(--muted)}
  </style>
  <script src="https://cdn.counter.dev/script.js" data-id="4efac50c-1140-4ff2-b4bb-b3459acc6129" data-utcoffset="2"></script>
</head>
<body>
  <header>
	<div style="
	  display:flex;
	  justify-content:space-between;
	  align-items:center;
	  margin-bottom:20px;
	  flex-wrap:wrap;
	  gap:10px;
	">
	  <div>
	    <h1 style="margin:0;">FairShuffle v0.44</h1>
	    <p style="margin:4px 0 0 0;">A smarter Spotify playlist shuffler</p>
	  </div>
	
	  <div>
	    <a href="https://buymeacoffee.com/FairShuffle" target="_blank">
	      <img 
	        src="https://img.buymeacoffee.com/button-api/?text=Buy%20me%20a%20coffee&emoji=â˜•&slug=FairShuffle&button_colour=1db954&font_colour=ffffff&font_family=Inter&outline_colour=000000&coffee_colour=ffffff"
	        alt="Buy Me A Coffee"
	        style="height:40px; border-radius:8px;"
	      >
	    </a>
	  </div>
	</div>
  </header>

  <main>
    <div class="card" id="authCard">
      <div class="row" style="align-items:center">
        <div>
          <div class="muted">Step 1</div>
          <h3 style="margin:4px 0 8px">Connect your Spotify</h3>
          <p class="muted">Click the button and approve access. You can disconnect anytime from your <a class="link" href="https://www.spotify.com/account/apps/" target="_blank" rel="noopener">Spotify Apps</a> page.</p>
        </div>
        <div style="min-width:220px;display:flex;gap:8px;align-items:center;justify-content:flex-end">
          <button id="loginBtn">Log in with Spotify</button>
          <button id="logoutBtn" class="danger hidden">Log out</button>
        </div>
      </div>
      <div id="whoami" class="muted hidden"></div>
    </div>

    <div class="card hidden" id="playlistCard">
      <div class="row">
        <div>
          <label for="playlistSel">Step 2 â€” Choose a playlist</label>
          <select id="playlistSel"></select>
          <div class="muted" id="playlistMeta" style="margin-top:6px"></div>
        </div>
        <div>
          <label for="createName">New playlist name (output)</label>
          <input id="createName" type="text" placeholder="e.g., Fair Shuffle â€” {Original Name}" />
        </div>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
        <button id="analyzeBtn">Analyze & preview</button>
        <button id="shuffleBtn" disabled>Shuffle & create playlist</button>
        <span class="pill"><span id="counts">â€”</span></span>
      </div>
    </div>

    <div class="card hidden" id="previewCard">
      <h3 style="margin:4px 0 8px">Step 3 â€” Preview & confirm</h3>
      <div class="muted">We'll evenly distribute songs by the same artist using their ideal spacing. The preview shows the first 50 items of the new order.</div>
      <div class="row" style="margin-top:12px">
        <div>
          <label>Original (first 50)</label>
          <ol id="origList"></ol>
        </div>
        <div>
          <label>Proposed order (first 50)</label>
          <ol id="newList"></ol>
        </div>
      </div>
    </div>

    <div class="card hidden" id="progressCard">
      <h3 style="margin:4px 0 8px">Workingâ€¦</h3>
      <progress id="progress" max="100" value="0"></progress>
      <div id="log" class="logs" style="margin-top:10px;min-height:80px"></div>
    </div>
  </main>

  <footer>
    <div class="muted">
      Tip: Large playlists are processed in chunks of 50 tracks (reading) and 100 tracks (writing) to respect Spotify's limits. Keep this tab open until it's finished.
    </div>
    <br>
    <div style="margin-top:20px;">
      <p class="muted" style="margin-bottom:8px;">
        
      Enjoying FairShuffle? You can support the project below â˜•ðŸ’š
      </p>

      <a href="https://www.buymeacoffee.com/FairShuffle" target="_blank">
        <img 
        src="https://img.buymeacoffee.com/button-api/?text=Buy%20me%20a%20coffee&emoji=â˜•&slug=FairShuffle&button_colour=1db954&font_colour=ffffff&font_family=Inter&outline_colour=000000&coffee_colour=ffffff"
        alt="Buy me a coffee"
        height="42">
      </a>
    </div>
  </footer>

  <script>
    // =====================
    // CONFIG â€” EDIT THIS
    // =====================
    const CLIENT_ID = "a62a280f59fd41f2977cdf5429d1ff87"; // <- from Spotify Developer Dashboard
    const REDIRECT_URI = "https://kosmosaik.github.io/FairShuffle/"; // ensure this exact URL is whitelisted in your app settings
    const SCOPES = [
      "playlist-read-private",
      "playlist-read-collaborative",
      "playlist-modify-private",
      "playlist-modify-public"
    ];

    // =====================
    // Spotify OAuth â€” PKCE
    // =====================
    // Uses Authorization Code with PKCE, no secret required.
    const loginBtn = document.getElementById('loginBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const whoami = document.getElementById('whoami');

    const auth = {
      access_token: null,
      refresh_token: null,
      expires_at: 0,
    };

    function setToken(t, expiresInSec){
      auth.access_token = t;
      auth.expires_at = Date.now() + (expiresInSec * 1000) - 5000;
      sessionStorage.setItem('sp_token', auth.access_token);
      sessionStorage.setItem('sp_expires_at', String(auth.expires_at));
    }

    function restoreToken(){
      const t = sessionStorage.getItem('sp_token');
      const e = sessionStorage.getItem('sp_expires_at');
      if(t && e && Number(e) > Date.now()){
        auth.access_token = t; auth.expires_at = Number(e);
        return true;
      }
      return false;
    }

    async function sha256(str){
      const data = new TextEncoder().encode(str);
      const digest = await crypto.subtle.digest('SHA-256', data);
      return new Uint8Array(digest);
    }
    function base64url(buf){
      let s = btoa(String.fromCharCode.apply(null, [...buf]));
      return s.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    function randomString(len=64){
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let out = '';
      for(let i=0;i<len;i++){ out += chars[Math.floor(Math.random()*chars.length)]; }
      return out;
    }

    async function beginLogin(){
      const verifier = randomString(96);
      const challenge = base64url(await sha256(verifier));
      sessionStorage.setItem('sp_code_verifier', verifier);
      const params = new URLSearchParams({
        response_type: 'code',
        client_id: CLIENT_ID,
        code_challenge_method: 'S256',
        code_challenge: challenge,
        redirect_uri: REDIRECT_URI,
        scope: SCOPES.join(' '),
        show_dialog: 'true'
      });
      window.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
    }

    async function completeLoginIfReturning(){
      const url = new URL(window.location.href);
      const code = url.searchParams.get('code');
      if(!code) return false;
      logUI('Exchanging codeâ€¦');
      const verifier = sessionStorage.getItem('sp_code_verifier');
      const body = new URLSearchParams({
        client_id: CLIENT_ID,
        grant_type: 'authorization_code',
        code: code,
        redirect_uri: REDIRECT_URI,
        code_verifier: verifier
      });
      const res = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body
      });
      if(!res.ok){ alert('Auth error. Check Client ID and Redirect URI.'); return false; }
      const data = await res.json();
      setToken(data.access_token, data.expires_in);
      history.replaceState({}, document.title, REDIRECT_URI); // clean code param
      return true;
    }

    function isAuthed(){ return !!auth.access_token; }

    // =====================
    // Simple API helper
    // =====================
    async function api(path, opts={}){
      const res = await fetch(`https://api.spotify.com/v1${path}`, {
        ...opts,
        headers: { 'Authorization': `Bearer ${auth.access_token}`, 'Content-Type':'application/json', ...(opts.headers||{}) }
      });
      if(res.status === 401){
        throw new Error('Unauthorized. Token expired or invalid. Log in again.');
      }
      if(!res.ok){
        const txt = await res.text();
        throw new Error(`API ${res.status}: ${txt}`);
      }
      if(res.status === 204) return null;
      return res.json();
    }

    // =====================
    // UI wiring: playlists
    // =====================
    const playlistCard = document.getElementById('playlistCard');
    const playlistSel = document.getElementById('playlistSel');
    const playlistMeta = document.getElementById('playlistMeta');
    const countsEl = document.getElementById('counts');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const createName = document.getElementById('createName');

    async function loadMe(){
      const me = await api('/me');
      whoami.classList.remove('hidden');
      whoami.textContent = `Logged in as ${me.display_name || me.id}`;
      return me;
    }

    async function loadPlaylists(){
      playlistSel.innerHTML = '';
      let next = '/me/playlists?limit=50';
      const all = [];
      while(next){
        const page = await api(next.replace('https://api.spotify.com/v1',''));
        all.push(...page.items);
        next = page.next;
      }
      all.sort((a,b)=> (b.tracks?.total||0) - (a.tracks?.total||0));
      for(const p of all){
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = `${p.name} â€” ${p.tracks.total} items ${p.owner?.display_name ? ' â€¢ by '+p.owner.display_name : ''}`;
        opt.dataset.total = p.tracks.total;
        playlistSel.appendChild(opt);
      }
      onPlaylistChange();
    }

    function onPlaylistChange(){
      const sel = playlistSel.selectedOptions[0];
      const total = Number(sel?.dataset.total||0);
      playlistMeta.textContent = total ? `${total} items` : '';
      createName.value = `Fair Shuffle â€” ${sel?.textContent?.split(' â€” ')[0]||'My Playlist'}`;
      countsEl.textContent = 'â€”';
      shuffleBtn.disabled = true;
    }
    playlistSel.addEventListener('change', onPlaylistChange);

    // =====================
    // Fetch playlist items with paging
    // =====================
    async function getPlaylistTracks(playlistId){
      const items = [];
      let url = `/playlists/${playlistId}/tracks?limit=50&fields=items(track(id,uri,name,artists(id,name))),next,total`;
      while(url){
        const page = await api(url);
        page.items.forEach(it=>{
          const t = it.track; if(!t || !t.uri) return;
          items.push({
            uri: t.uri,
            name: t.name,
            artistId: (t.artists && t.artists[0] && t.artists[0].id) || 'unknown',
            artist: (t.artists && t.artists[0] && t.artists[0].name) || 'Unknown'
          });
        });
        url = page.next ? page.next.replace('https://api.spotify.com/v1','') : null;
        progressTick(items.length, page.total||items.length);
      }
      return items;
    }

    // =====================
    // Fair Artist Distribution Shuffle
    // =====================
	function fairShuffle(tracks) {
	  const total = tracks.length;
	  const byArtist = {};
	
	  // Group by artist
	  for (const t of tracks) {
	    if (!byArtist[t.artistId]) byArtist[t.artistId] = [];
	    byArtist[t.artistId].push(t);
	  }
	
	  // Sort artists by number of tracks (most â†’ fewest)
	  const artists = Object.entries(byArtist).sort((a, b) => b[1].length - a[1].length);
	
	  const result = new Array(total);
	  const used = new Set();
	
	  // Assign random offset for each artist
	  const offsets = Object.fromEntries(artists.map(([a]) => [a, Math.floor(Math.random() * total)]));
	
	  // Place each artist's songs evenly with small jitter
	  for (const [artist, songs] of artists) {
	    const idealStep = total / songs.length;
	    const jitter = idealStep * 0.15; // 15% randomness
	
	    for (let i = 0; i < songs.length; i++) {
	      let pos = Math.floor((i * idealStep + offsets[artist]) % total);
	      pos = (pos + Math.floor((Math.random() - 0.5) * jitter) + total) % total;
	
	      // Find nearest empty slot
	      while (result[pos]) pos = (pos + 1) % total;
	      result[pos] = songs[i];
	      used.add(songs[i].uri);
	    }
	  }
	
	  // Fill remaining gaps (if any)
	  for (const t of tracks) {
	    if (!used.has(t.uri)) {
	      let pos = Math.floor(Math.random() * total);
	      while (result[pos]) pos = (pos + 1) % total;
	      result[pos] = t;
	      used.add(t.uri);
	    }
	  }
	
	  // Quick anti-adjacency repair pass
	  let repairs = 0;
	  for (let i = 1; i < result.length; i++) {
	    if (result[i].artistId === result[i - 1].artistId) {
	      const swapIdx = (i + Math.floor(total / 2)) % total;
	      [result[i], result[swapIdx]] = [result[swapIdx], result[i]];
	      repairs++;
	    }
	  }
	
	  console.log(`ðŸ”€ Fair shuffle complete â€” ${repairs} adjacency fixes made`);
	  return result;
	}


	// =====================
	// Enforce Spacing By Insertion
	// =====================
	function enforceSpacingByInsertion(tracks, tolerance = 0.7, maxRounds = 25) {
	  const total = tracks.length;
	  const norm = i => ((i % total) + total) % total;
	  const circDist = (a, b) => {
	    const d = Math.abs(a - b);
	    return Math.min(d, total - d);
	  };
	
	  function buildPositions(arr) {
	    const map = new Map();
	    for (let i = 0; i < arr.length; i++) {
	      const a = arr[i].artistId;
	      if (!map.has(a)) map.set(a, []);
	      map.get(a).push(i);
	    }
	    for (const list of map.values()) list.sort((x, y) => x - y);
	    return map;
	  }
	
	  let moved = 0;
	  const artistNames = new Map();
	  for (const t of tracks) {
	    if (!artistNames.has(t.artistId)) {
	      artistNames.set(t.artistId, t.artist || t.artistName || t.artistId);
	    }
	  }
	  for (let round = 0; round < maxRounds; round++) {
	    let changed = false;
	    const posByArtist = buildPositions(tracks);
	
	    // Iterate artists; on the first fix we restart the round to keep indices fresh
		const sortedArtists = [...posByArtist.entries()].sort((a, b) => {
		  const dA = a[1].length < 2 ? Infinity : Math.min(...a[1].map((v, i, arr) =>
		    i ? (v - arr[i - 1] + total) % total : total
		  ));
		  const dB = b[1].length < 2 ? Infinity : Math.min(...b[1].map((v, i, arr) =>
		    i ? (v - arr[i - 1] + total) % total : total
		  ));
		  return dA - dB;
		});

		  console.log("ðŸ‘ï¸ Checking top 5 tightest artists this round:",
		  	sortedArtists.slice(0, 5).map(([a, p]) => `${artistNames.get(a)} (${p.length})`)
		);
		
		// Iterate artists in that order
		outer:
		for (const [artist, posList] of sortedArtists) {
		  const count = posList.length;
		  if (count < 2) continue;
		
		  const idealStep = total / count;
		  const minAllowed = idealStep * tolerance;
		
		  for (let k = 1; k <= posList.length; k++) {  // âœ… note: wrap-around check
		    const prev = posList[k - 1];
		    const curr = posList[k % posList.length];
		    const dist = (curr - prev + total) % total; // âœ… circular gap
		
		    if (dist < minAllowed) {
		      // --- pick a good target near prev + idealStep ---
		      const base = norm(Math.round(prev + idealStep));
		
		      // Search candidates spaced by ~idealStep (a few hops), then widen locally
		      let best = null;
		      let bestScore = -1;
	
	          // First: try ideal multiples ahead of prev
	          for (let step = 1; step <= Math.min(count + 2, 8); step++) {
	            const cand = norm(Math.round(prev + step * idealStep));
	            // Score by nearest circular distance to any same-artist track (including prev/curr)
	            let nearest = Infinity;
	            for (const p of posList) nearest = Math.min(nearest, circDist(cand, p));
	            if (nearest > bestScore) { bestScore = nearest; best = cand; }
	            if (nearest >= minAllowed) break; // good enough
	          }
	
	          // Second: if needed, nudge around best to avoid local adjacency and improve room
	          if (best != null) {
	            for (let delta = 0; delta < Math.min(200, total); delta++) {
	              const cand1 = norm(best + delta);
	              const cand2 = norm(best - delta);
	              for (const cand of [cand1, cand2]) {
	                // skip if would be adjacent to same artist
	                const left  = tracks[cand - 1]?.artistId;
	                const here  = tracks[cand]?.artistId; // insertion point element
	                const right = tracks[cand + 1]?.artistId;
	                if (here !== artist && left !== artist && right !== artist) {
	                  // pick the one with max min distance to same-artist positions
	                  let nearest = Infinity;
	                  for (const p of posList) nearest = Math.min(nearest, circDist(cand, p));
	                  if (nearest >= minAllowed || nearest > bestScore) {
	                    best = cand; bestScore = nearest;
	                    if (nearest >= minAllowed) break;
	                  }
	                }
	              }
	              if (bestScore >= minAllowed) break;
	            }
	          } else {
	            best = base;
	          }
	
	          // --- execute the move (and restart round) ---
	          const [song] = tracks.splice(curr, 1);
	          // Adjust target when removing before insertion point
	          let target = best;
	          if (curr < best) target--;           // account for left shift post-removal
	          target = norm(target);
	
	          tracks.splice(target, 0, song);
			  const name = artistNames.get(artist) || artist;
			  console.log(`ðŸŽ¯ Moved "${name}" track to index ${target} (round ${round + 1})`);

	          moved++;
	          changed = true;
			  posByArtist.set(artist, buildPositions(tracks).get(artist));
	          break outer;                         // âœ… restart round with fresh positions
	        }
	      }
	    }
	
	    if (!changed) break;
	  }
	
	  console.log(`ðŸ§© Enforced ideal spacing (tol=${tolerance}, rounds=${maxRounds}) â€” moved ${moved} tracks`);
	  return tracks;
	}


	// =====================
	// Analysis table + closest distance debug
	// =====================
	function analyzeArtistSpacing(tracks) {
	  const total = tracks.length;
	  const circDist = (a, b) => {
	    const d = Math.abs(a - b);
	    return Math.min(d, total - d);
	  };
	
	  const positions = new Map();
	  for (let i = 0; i < total; i++) {
	    const key = tracks[i].artist || tracks[i].artistName || tracks[i].artistId;
	    if (!positions.has(key)) positions.set(key, []);
	    positions.get(key).push(i);
	  }
	
	  const results = [];
	  let globalMin = Infinity;
	  const offenders = [];
	
	  for (const [artist, idxs] of positions.entries()) {
	    idxs.sort((a, b) => a - b);
	    const n = idxs.length;
	    const ideal = (total / n);
	
	    const dists = [];
	    for (let i = 1; i < n; i++) dists.push(circDist(idxs[i], idxs[i - 1]));
	    if (n > 1) dists.push(circDist(idxs[0], idxs[n - 1]));   // âœ… include wrap
	
	    const avg = dists.length ? (dists.reduce((a, b) => a + b, 0) / dists.length) : 0;
	    const minD = dists.length ? Math.min(...dists) : 0;
	
	    if (dists.length && minD < globalMin) {
	      globalMin = minD;
	    }
	    results.push({
	      artist,
	      count: n,
	      idealDist: Number(ideal.toFixed(1)),   // âœ… explicit ideal
	      avgDist: Number(avg.toFixed(1)),       // average *circular* distance
	      minDist: minD,
	      distances: dists,
	      positions: idxs
	    });
	  }
	
	  // mark offenders that match global min
	  for (const r of results) if (r.minDist === globalMin) offenders.push(r.artist);
	
	  // sort examples
	  const topByCount = [...results].sort((a, b) => b.count - a.count).slice(0, 25);
	  const topByClosest = [...results]
		  .filter(r => r.count > 1)              // âœ… exclude single-track artists
		  .sort((a, b) => a.minDist - b.minDist)
		  .slice(0, 25);

	
	  console.table(topByCount.map(r => ({
	    Artist: r.artist, Tracks: r.count, Ideal: r.idealDist, 'Avg Dist (circ)': r.avgDist, 'Min Dist': r.minDist
	  })));
	  console.log(`âš ï¸ Closest circular distance found: ${globalMin} between ${offenders.join(', ')}`);
	
	  // (UI table code can be updated similarly to show Ideal as a column)
		// ---- OPTIONAL: rebuild on-page tables ----
		document.querySelectorAll("#analysisTable").forEach(e => e.remove());
		const makeTable = (title, rows) => `
		  <div style="margin:24px 0;">
			<h4 style="margin-bottom:8px;">${title}</h4>
			<table style="width:95%; border-collapse:collapse; font-family:monospace; color:#cfe3ff;
						  background:#0c121a; border-radius:12px; overflow:hidden;">
			  <thead style="background:#111a22;">
				<tr><th style="text-align:left;padding:6px;">Artist</th>
					<th>Tracks</th><th>Ideal</th><th>Avg Dist (circ)</th><th>Min Dist</th></tr>
			  </thead>
			  <tbody>
				${rows.map(r => `
				  <tr>
					<td style="padding:6px;">${r.artist}</td>
					<td style="text-align:center;">${r.count}</td>
					<td style="text-align:center;">${r.idealDist}</td>
					<td style="text-align:center;">${r.avgDist}</td>
					<td style="text-align:center;">${r.minDist}</td>
				  </tr>`).join("")}
			  </tbody>
			</table>
		  </div>`;
		
		const html = `
		  <div id="analysisTable">
			<h3 style="margin-bottom:12px;">Artist Spacing Summary</h3>
			${makeTable("Top 25 artists (by track count)", topByCount)}
			${makeTable("25 artists with smallest minimum spacing", topByClosest)}
		  </div>`;
		document.body.insertAdjacentHTML("beforeend", html);
		// ---- END optional tables ----

	  return results;
	}


    // =====================
    // Preview & actions
    // =====================
    const previewCard = document.getElementById('previewCard');
    const origList = document.getElementById('origList');
    const newList = document.getElementById('newList');

    let cachedTracks = [];
    let proposed = [];

    function renderFirst50(){
      origList.innerHTML = '';
      newList.innerHTML = '';
      for(const t of cachedTracks.slice(0,50)){
        const li = document.createElement('li'); li.textContent = `${t.artist} â€” ${t.name}`; origList.appendChild(li);
      }
      for(const t of proposed.slice(0,50)){
        const li = document.createElement('li'); li.textContent = `${t.artist} â€” ${t.name}`; newList.appendChild(li);
      }
    }

    analyzeBtn.addEventListener('click', async ()=>{
	  try{
	    const pid = playlistSel.value;
	    if(!pid) return;
	
	    // Hide old preview + reset UI early
	    previewCard.classList.add('hidden');
	    shuffleBtn.disabled = true;
	    progressCard.classList.remove('hidden');
	    progressBar.value = 0;
	    logEl.textContent = '';
	    logUI('Loading playlist itemsâ€¦');
        cachedTracks = await getPlaylistTracks(pid);
        const total = cachedTracks.length;
        const byArtist = new Map();
        for(const t of cachedTracks){
          const k = t.artistId; if(!byArtist.has(k)) byArtist.set(k,[]); byArtist.get(k).push(t);
        }
        // Compute stats
        const maxArtist = [...byArtist.values()].reduce((m,arr)=> Math.max(m,arr.length), 0);
        const idealStep = (aCount)=> (total / aCount).toFixed(1);
        countsEl.textContent = `${total} tracks â€¢ ${byArtist.size} artists â€¢ densest artist has ${maxArtist} tracks (ideal spacing â‰ˆ ${idealStep(maxArtist)})`;

// ==============================================		  
        proposed = fairShuffle(cachedTracks);
		const before = analyzeArtistSpacing(proposed);
		proposed = enforceSpacingByInsertion(proposed, 0.7, 25);
		const after = analyzeArtistSpacing(proposed);
        renderFirst50();
// ==============================================	
		  
        previewCard.classList.remove('hidden');
        shuffleBtn.disabled = false;
        hideProgress();
      }catch(e){
        alert(e.message);
        hideProgress();
      }
    });

    // UPDATED SHUFFLE HANDLER ONLY
        shuffleBtn.addEventListener('click', async ()=>{
      try{
        const pid = playlistSel.value; if(!pid) return;
        if(!proposed.length){ alert('Run Analyze first.'); return; }
        const me = await api('/me');
        const name = (createName.value || 'Fair Shuffle');
        showProgress();
    
        // NEW modal choice
        const choice = await getUserChoice();
        if (choice === 'cancel') {
          logUI('âŒ Cancelled by user.');
          hideProgress();
          return;
        }
    
        let targetId = pid;
        let targetName = playlistSel.selectedOptions[0]?.textContent || name;
    
        if (choice === 'overwrite') {
          logUI('Overwriting existing playlistâ€¦');
          await api(`/playlists/${targetId}/tracks`, { method:'PUT', body: JSON.stringify({ uris: [] }) });
        } else if (choice === 'create') {
          logUI('Creating new playlistâ€¦');
          const created = await api(`/users/${encodeURIComponent(me.id)}/playlists`, {
            method:'POST',
            body: JSON.stringify({ name, description:'Auto-created with Fair Artist Shuffle', public:false })
          });
          targetId = created.id;
          targetName = created.name;
        }
    
        // Add items in batches of 100
        const uris = proposed.map(t=>t.uri);
        let i = 0;
        while(i < uris.length){
          const chunk = uris.slice(i, i+100);
          logUI(`Adding items ${i+1}â€“${i+chunk.length} of ${uris.length}â€¦`);
          await api(`/playlists/${targetId}/tracks`, { method:'POST', body: JSON.stringify({ uris: chunk }) });
          i += chunk.length;
          progressTick(i, uris.length);
        }
    
        logUI(`Done! Open your playlist: https://open.spotify.com/playlist/${targetId}`);
        alert(choice === 'overwrite'
          ? `âœ… The playlist "${targetName}" has been overwritten with the new shuffled order!`
          : `âœ… A new playlist "${targetName}" has been created!`);
        hideProgress();
      }catch(e){
        alert(e.message);
        hideProgress();
      }
    });

    // =====================
    // Progress + logs
    // =====================
    const progressCard = document.getElementById('progressCard');
    const progressBar = document.getElementById('progress');
    const logEl = document.getElementById('log');

    function showProgress(){ progressCard.classList.remove('hidden'); progressBar.value = 0; logEl.textContent = ''; }
    function hideProgress(){ /* keep visible with logs */ }
    function progressTick(done, total){ progressBar.max = total; progressBar.value = done; }
    function logUI(msg){ logEl.textContent += (logEl.textContent?"\n":"") + msg; }

    // =====================
    // Boot
    // =====================
    loginBtn.addEventListener('click', beginLogin);
    logoutBtn.addEventListener('click', ()=>{ sessionStorage.clear(); location.reload(); });

    (async function init(){
      if(await completeLoginIfReturning() || restoreToken()){
        loginBtn.classList.add('hidden');
        logoutBtn.classList.remove('hidden');
        await loadMe();
        playlistCard.classList.remove('hidden');
        loadPlaylists();
      }
    })();
  </script>

  <!-- Modal overlay -->
  <div id="overlay" style="position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:1000;">
    <div id="choiceDialog" style="background:#121923;border:1px solid #263445;border-radius:16px;padding:20px;text-align:center;max-width:320px;box-shadow:0 4px 20px rgba(0,0,0,.5);">
      <h3 style="margin-top:0;margin-bottom:16px;">Choose what to do with your playlist</h3>
      <button id="overwriteBtn" style="appearance:none;border:0;border-radius:999px;padding:10px 16px;background:#1db954;color:#082412;font-weight:700;cursor:pointer;margin:6px;">Overwrite</button>
      <button id="createBtn" style="appearance:none;border:0;border-radius:999px;padding:10px 16px;background:#1db954;color:#082412;font-weight:700;cursor:pointer;margin:6px;">Create New</button>
      <button id="cancelBtn" style="appearance:none;border:0;border-radius:999px;padding:10px 16px;background:#1db954;color:#082412;font-weight:700;cursor:pointer;margin:6px;">Cancel</button>
    </div>
  </div>

  <script>
    const overlay = document.getElementById('overlay');
    const overwriteBtn = document.getElementById('overwriteBtn');
    const createBtn = document.getElementById('createBtn');
    const cancelBtn = document.getElementById('cancelBtn');

    function getUserChoice(){
      return new Promise(resolve => {
        overlay.style.display = 'flex';
        overwriteBtn.onclick = () => { overlay.style.display='none'; resolve('overwrite'); };
        createBtn.onclick = () => { overlay.style.display='none'; resolve('create'); };
        cancelBtn.onclick = () => { overlay.style.display='none'; resolve('cancel'); };
      });
    }
  </script>
<script>
	(function(){
		const logBox = document.createElement('div');
		Object.assign(logBox.style, {
			position: 'fixed',
			bottom: '0',
			left: '0',
			right: '0',
			maxHeight: '30vh',
			overflowY: 'auto',
			background: 'rgba(0,0,0,0.8)',
			color: '#0f0',
			fontSize: '12px',
			fontFamily: 'monospace',
			padding: '6px',
			zIndex: '9999',
			whiteSpace: 'pre-wrap'
		});
		document.body.appendChild(logBox);

		const oldLog = console.log;
		console.log = (...args) => {
			oldLog(...args);
			logBox.textContent += args.map(a=>typeof a==='object'?JSON.stringify(a):a).join(' ') + '\n';
			logBox.scrollTop = logBox.scrollHeight;
		};
	})();
</script>


</body>
</html>
